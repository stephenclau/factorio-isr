============================= test session starts ==============================
platform linux -- Python 3.14.0, pytest-9.0.1, pluggy-1.6.0 -- /home/slau/code/factorio-isr/venv/bin/python
cachedir: .pytest_cache
rootdir: /home/slau/code/factorio-isr
configfile: pyproject.toml
plugins: asyncio-1.3.0, mock-3.15.1, cov-7.0.0
asyncio: mode=Mode.AUTO, debug=False, asyncio_default_fixture_loop_scope=function, asyncio_default_test_loop_scope=function
collecting ... 2025-12-03 15:58:28 [debug    ] cooldown_initialized           per=30.0 rate=5
2025-12-03 15:58:28 [debug    ] cooldown_initialized           per=60.0 rate=3
2025-12-03 15:58:28 [debug    ] cooldown_initialized           per=120.0 rate=1
collected 65 items

tests/test_discord_bot_comprehensive.py::test_init_default FAILED
tests/test_discord_bot_comprehensive.py::test_init_custom_bot_name FAILED
tests/test_discord_bot_comprehensive.py::test_set_event_channel 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=123456789
PASSED
tests/test_discord_bot_comprehensive.py::test_set_rcon_client 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
PASSED
tests/test_discord_bot_comprehensive.py::test_is_connected_property 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
FAILED
tests/test_discord_bot_comprehensive.py::test_factory_create_bot FAILED
tests/test_discord_bot_comprehensive.py::test_register_commands 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
PASSED
tests/test_discord_bot_comprehensive.py::test_setup_hook 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] discord_bot_setup_complete
PASSED
tests/test_discord_bot_comprehensive.py::test_ping_command_success 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
2025-12-03 15:58:29 [info     ] factorio_ping_success          user=TestUser
PASSED
tests/test_discord_bot_comprehensive.py::test_ping_command_no_rcon 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
FAILED
tests/test_discord_bot_comprehensive.py::test_ping_command_rcon_error 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
FAILED
tests/test_discord_bot_comprehensive.py::test_status_command_rcon_connected 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
PASSED
tests/test_discord_bot_comprehensive.py::test_status_command_rcon_disconnected 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
PASSED
tests/test_discord_bot_comprehensive.py::test_players_command_success 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
2025-12-03 15:58:29 [debug    ] rate_limited                   identifier=123456 per=30.0 rate=5 retry_after=29.868663787841797
FAILED
tests/test_discord_bot_comprehensive.py::test_players_command_rcon_not_connected 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
2025-12-03 15:58:29 [debug    ] rate_limited                   identifier=123456 per=30.0 rate=5 retry_after=29.83132004737854
FAILED
tests/test_discord_bot_comprehensive.py::test_version_command 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
2025-12-03 15:58:29 [debug    ] rate_limited                   identifier=123456 per=30.0 rate=5 retry_after=29.79526710510254
FAILED
tests/test_discord_bot_comprehensive.py::test_update_presence_rcon_connected 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
FAILED
tests/test_discord_bot_comprehensive.py::test_update_presence_rcon_disconnected 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
FAILED
tests/test_discord_bot_comprehensive.py::test_monitor_rcon_status_transition 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] rcon_client_set_for_bot_commands
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=123456
2025-12-03 15:58:29 [info     ] rcon_status_monitor_started
FAILED
tests/test_discord_bot_comprehensive.py::test_notify_rcon_disconnected 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=123456
2025-12-03 15:58:29 [info     ] rcon_disconnection_notified    channel_id=123456
PASSED
tests/test_discord_bot_comprehensive.py::test_notify_rcon_reconnected 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=123456
2025-12-03 15:58:29 [info     ] rcon_reconnection_notified     channel_id=123456
PASSED
tests/test_discord_bot_comprehensive.py::test_on_ready 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] discord_bot_ready              bot_id=12345 bot_name=<MagicMock name='TestBot.name' id='136987639582064'> guilds=1 phase=5.2
2025-12-03 15:58:29 [info     ] commands_synced_globally       commands=[] count=0
2025-12-03 15:58:29 [info     ] commands_synced_to_guild       command_count=0 guild_id=111 guild_name=<MagicMock name='Guild1.name' id='136987639589120'>
FAILED
tests/test_discord_bot_comprehensive.py::test_on_disconnect 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [warning  ] discord_bot_disconnected
FAILED
tests/test_discord_bot_comprehensive.py::test_on_error 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
FAILED
tests/test_discord_bot_comprehensive.py::test_connect_bot 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
FAILED
tests/test_discord_bot_comprehensive.py::test_disconnect_bot 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
FAILED
tests/test_discord_bot_comprehensive.py::test_send_connection_notification 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=123456
2025-12-03 15:58:29 [info     ] connection_notification_sent   channel_id=123456
PASSED
tests/test_discord_bot_comprehensive.py::test_send_disconnection_notification 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=123456
2025-12-03 15:58:29 [debug    ] skip_disconnection_notification_not_connected
FAILED
tests/test_discord_bot_comprehensive.py::test_send_event_success 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=123456
2025-12-03 15:58:29 [warning  ] send_event_not_connected       event_type=player_join
FAILED
tests/test_discord_bot_comprehensive.py::test_send_event_not_connected 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [warning  ] send_event_not_connected       event_type=test
PASSED
tests/test_discord_bot_comprehensive.py::test_send_event_no_channel 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [warning  ] send_event_not_connected       event_type=test
PASSED
tests/test_discord_bot_comprehensive.py::test_send_event_channel_not_found 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=999999
2025-12-03 15:58:29 [warning  ] send_event_not_connected       event_type=test
PASSED
tests/test_discord_bot_comprehensive.py::test_send_event_forbidden_error 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] event_channel_set              channel_id=123456
2025-12-03 15:58:29 [warning  ] send_event_not_connected       event_type=test
PASSED
tests/test_discord_bot_comprehensive.py::test_all_commands_registered 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] slash_commands_registered      command_count=23 phase=5.2 root=factorio
PASSED
tests/test_discord_bot_comprehensive.py::test_clear_global_commands 2025-12-03 15:58:29 [info     ] discord_bot_initialized        bot_name=TestBot phase=5.2
2025-12-03 15:58:29 [info     ] global_commands_cleared
PASSED
tests/test_discord_bot_booster.py::test_seed_command ERROR
tests/test_discord_bot_booster.py::test_evolution_command ERROR
tests/test_discord_bot_booster.py::test_admins_command ERROR
tests/test_discord_bot_booster.py::test_health_command_all_online ERROR
tests/test_discord_bot_booster.py::test_health_command_rcon_offline ERROR
tests/test_discord_bot_booster.py::test_kick_command_with_reason ERROR
tests/test_discord_bot_booster.py::test_kick_command_without_reason ERROR
tests/test_discord_bot_booster.py::test_ban_command ERROR
tests/test_discord_bot_booster.py::test_unban_command ERROR
tests/test_discord_bot_booster.py::test_mute_command ERROR
tests/test_discord_bot_booster.py::test_unmute_command ERROR
tests/test_discord_bot_booster.py::test_promote_command ERROR
tests/test_discord_bot_booster.py::test_demote_command ERROR
tests/test_discord_bot_booster.py::test_save_command_with_name ERROR
tests/test_discord_bot_booster.py::test_save_command_auto_name ERROR
tests/test_discord_bot_booster.py::test_broadcast_command ERROR
tests/test_discord_bot_booster.py::test_whitelist_list ERROR
tests/test_discord_bot_booster.py::test_whitelist_add ERROR
tests/test_discord_bot_booster.py::test_whitelist_remove ERROR
tests/test_discord_bot_booster.py::test_whitelist_enable ERROR
tests/test_discord_bot_booster.py::test_whitelist_disable ERROR
tests/test_discord_bot_booster.py::test_whitelist_invalid_action ERROR
tests/test_discord_bot_booster.py::test_time_command_display ERROR
tests/test_discord_bot_booster.py::test_time_command_set ERROR
tests/test_discord_bot_booster.py::test_speed_command_valid ERROR
tests/test_discord_bot_booster.py::test_speed_command_too_low ERROR
tests/test_discord_bot_booster.py::test_speed_command_too_high ERROR
tests/test_discord_bot_booster.py::test_research_command ERROR
tests/test_discord_bot_booster.py::test_rcon_command ERROR
tests/test_discord_bot_booster.py::test_help_command ERROR

==================================== ERRORS ====================================
_____________________ ERROR at setup of test_seed_command ______________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb19ae40>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb1068d0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb1068d0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb1068d0>>}
http = <discord.http.HTTPClient object at 0x7c96eba13f50>
options = {'intents': <MagicMock name='default()' id='136987631267056'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
___________________ ERROR at setup of test_evolution_command ___________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96ebd1cc20>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96ebbd5010>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96ebbd5010>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96ebbd5010>>}
http = <discord.http.HTTPClient object at 0x7c96eba10e90>
options = {'intents': <MagicMock name='default()' id='136987643332656'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
____________________ ERROR at setup of test_admins_command _____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96ebd1d010>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96ebbd4dd0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96ebbd4dd0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96ebbd4dd0>>}
http = <discord.http.HTTPClient object at 0x7c96eba10a10>
options = {'intents': <MagicMock name='default()' id='136987643334336'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_______________ ERROR at setup of test_health_command_all_online _______________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb19b0e0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb107530>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb107530>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb107530>>}
http = <discord.http.HTTPClient object at 0x7c96eb12c590>
options = {'intents': <MagicMock name='default()' id='136987631268736'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
______________ ERROR at setup of test_health_command_rcon_offline ______________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb19ba10>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb107e30>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb107e30>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb107e30>>}
http = <discord.http.HTTPClient object at 0x7c96eb12c410>
options = {'intents': <MagicMock name='default()' id='136987631270752'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_______________ ERROR at setup of test_kick_command_with_reason ________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb1882f0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb19c4d0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb19c4d0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb19c4d0>>}
http = <discord.http.HTTPClient object at 0x7c96eb12c710>
options = {'intents': <MagicMock name='default()' id='136987631190432'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
______________ ERROR at setup of test_kick_command_without_reason ______________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb188830>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb19ca70>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb19ca70>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb19ca70>>}
http = <discord.http.HTTPClient object at 0x7c96eb12ca10>
options = {'intents': <MagicMock name='default()' id='136987631192448'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
______________________ ERROR at setup of test_ban_command ______________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb188ec0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96ebea2c30>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96ebea2c30>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96ebea2c30>>}
http = <discord.http.HTTPClient object at 0x7c96eb12cb90>
options = {'intents': <MagicMock name='default()' id='136987631194128'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_____________________ ERROR at setup of test_unban_command _____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb189550>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb19d5b0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb19d5b0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb19d5b0>>}
http = <discord.http.HTTPClient object at 0x7c96eb12cd10>
options = {'intents': <MagicMock name='default()' id='136987631195808'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_____________________ ERROR at setup of test_mute_command ______________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb189be0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb19db50>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb19db50>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb19db50>>}
http = <discord.http.HTTPClient object at 0x7c96eb12ce90>
options = {'intents': <MagicMock name='default()' id='136987631197488'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
____________________ ERROR at setup of test_unmute_command _____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb18a270>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb19e0f0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb19e0f0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb19e0f0>>}
http = <discord.http.HTTPClient object at 0x7c96eb12d010>
options = {'intents': <MagicMock name='default()' id='136987631199168'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
____________________ ERROR at setup of test_promote_command ____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb18a900>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb19e690>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb19e690>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb19e690>>}
http = <discord.http.HTTPClient object at 0x7c96eb12d190>
options = {'intents': <MagicMock name='default()' id='136987631200848'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
____________________ ERROR at setup of test_demote_command _____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb18af90>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb19ec30>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb19ec30>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb19ec30>>}
http = <discord.http.HTTPClient object at 0x7c96eb12d310>
options = {'intents': <MagicMock name='default()' id='136987631202528'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
________________ ERROR at setup of test_save_command_with_name _________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb18b620>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb19d010>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb19d010>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb19d010>>}
http = <discord.http.HTTPClient object at 0x7c96eb12d490>
options = {'intents': <MagicMock name='default()' id='136987631204208'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
________________ ERROR at setup of test_save_command_auto_name _________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb989400>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb2044d0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb2044d0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb2044d0>>}
http = <discord.http.HTTPClient object at 0x7c96eba125d0>
options = {'intents': <MagicMock name='default()' id='136987639584416'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
___________________ ERROR at setup of test_broadcast_command ___________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb198830>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb1056d0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb1056d0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb1056d0>>}
http = <discord.http.HTTPClient object at 0x7c96eba134d0>
options = {'intents': <MagicMock name='default()' id='136987631257312'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
____________________ ERROR at setup of test_whitelist_list _____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb199fd0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb1067b0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb1067b0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb1067b0>>}
http = <discord.http.HTTPClient object at 0x7c96eba13710>
options = {'intents': <MagicMock name='default()' id='136987631260336'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_____________________ ERROR at setup of test_whitelist_add _____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb19a270>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb106450>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb106450>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb106450>>}
http = <discord.http.HTTPClient object at 0x7c96eba13dd0>
options = {'intents': <MagicMock name='default()' id='136987631266048'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
___________________ ERROR at setup of test_whitelist_remove ____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb199be0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb105fd0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb105fd0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb105fd0>>}
http = <discord.http.HTTPClient object at 0x7c96eba10d10>
options = {'intents': <MagicMock name='default()' id='136987631261008'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
___________________ ERROR at setup of test_whitelist_enable ____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb2de900>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb104b90>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb104b90>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb104b90>>}
http = <discord.http.HTTPClient object at 0x7c96eba11e50>
options = {'intents': <MagicMock name='default()' id='136987632594832'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
___________________ ERROR at setup of test_whitelist_disable ___________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb989a90>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb104950>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb104950>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb104950>>}
http = <discord.http.HTTPClient object at 0x7c96eba12210>
options = {'intents': <MagicMock name='default()' id='136987632586768'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_______________ ERROR at setup of test_whitelist_invalid_action ________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb98a120>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb28fbf0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb28fbf0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb28fbf0>>}
http = <discord.http.HTTPClient object at 0x7c96eba12f90>
options = {'intents': <MagicMock name='default()' id='136987639581728'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_________________ ERROR at setup of test_time_command_display __________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb989be0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb28ed50>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb28ed50>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb28ed50>>}
http = <discord.http.HTTPClient object at 0x7c96eba13110>
options = {'intents': <MagicMock name='default()' id='136987639584080'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
___________________ ERROR at setup of test_time_command_set ____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb7bb4d0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb28dd90>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb28dd90>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb28dd90>>}
http = <discord.http.HTTPClient object at 0x7c96eb12c290>
options = {'intents': <MagicMock name='default()' id='136987637691264'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
__________________ ERROR at setup of test_speed_command_valid __________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb9378c0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb28e570>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb28e570>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb28e570>>}
http = <discord.http.HTTPClient object at 0x7c96eb12d6d0>
options = {'intents': <MagicMock name='default()' id='136987639249424'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_________________ ERROR at setup of test_speed_command_too_low _________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb935fd0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb1044d0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb1044d0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb1044d0>>}
http = <discord.http.HTTPClient object at 0x7c96eba13050>
options = {'intents': <MagicMock name='default()' id='136987639243040'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
________________ ERROR at setup of test_speed_command_too_high _________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb804c20>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb28ccb0>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb28ccb0>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb28ccb0>>}
http = <discord.http.HTTPClient object at 0x7c96eb12da90>
options = {'intents': <MagicMock name='default()' id='136987637993488'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
___________________ ERROR at setup of test_research_command ____________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb804440>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb28c830>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb28c830>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb28c830>>}
http = <discord.http.HTTPClient object at 0x7c96eb12d9d0>
options = {'intents': <MagicMock name='default()' id='136987637990128'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_____________________ ERROR at setup of test_rcon_command ______________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb804830>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb207410>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb207410>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb207410>>}
http = <discord.http.HTTPClient object at 0x7c96eb12dc10>
options = {'intents': <MagicMock name='default()' id='136987637991808'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
_____________________ ERROR at setup of test_help_command ______________________

    @pytest.fixture
    def bot():
        """Create a DiscordBot instance for testing"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TEST_TOKEN", bot_name="TestBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_booster.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96eb88aba0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96eb207770>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96eb207770>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96eb207770>>}
http = <discord.http.HTTPClient object at 0x7c96eb12dd90>
options = {'intents': <MagicMock name='default()' id='136987638540544'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
=================================== FAILURES ===================================
______________________________ test_init_default _______________________________

    def test_init_default():
        """Test DiscordBot initialization with defaults"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TOKEN123")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_comprehensive.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96ebd1cec0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96ebd1c980>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96ebd1c980>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96ebd1c980>>}
http = <discord.http.HTTPClient object at 0x7c96ebd1cd70>
options = {'intents': <MagicMock name='default()' id='136987643333328'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
__________________________ test_init_custom_bot_name ___________________________

    def test_init_custom_bot_name():
        """Test DiscordBot initialization with custom bot_name"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBot(token="TOKEN", bot_name="CustomBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_comprehensive.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96ebd1dbe0>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96ed671310>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96ed671310>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96ed671310>>}
http = <discord.http.HTTPClient object at 0x7c96eba442d0>
options = {'intents': <MagicMock name='default()' id='136987643337360'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
__________________________ test_is_connected_property __________________________

bot = <discord_bot.DiscordBot object at 0x7c96ebec3e10>

    def test_is_connected_property(bot):
        """Test is_connected property"""
        assert bot.is_connected is False
        bot.connected = True
>       assert bot.is_connected is True
E       assert False is True
E        +  where False = <discord_bot.DiscordBot object at 0x7c96ebec3e10>.is_connected

tests/test_discord_bot_comprehensive.py:152: AssertionError
___________________________ test_factory_create_bot ____________________________

    def test_factory_create_bot():
        """Test DiscordBotFactory.create_bot"""
        with patch('discord_bot.discord.Intents.default'):
>           bot = DiscordBotFactory.create_bot(token="FACTORY_TOKEN", bot_name="FactoryBot")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_discord_bot_comprehensive.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/discord_bot.py:1397: in create_bot
    return DiscordBot(token=token, bot_name=bot_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/discord_bot.py:53: in __init__
    super().__init__(intents=intents)
venv/lib/python3.14/site-packages/discord/client.py:331: in __init__
    self._connection: ConnectionState[Self] = self._get_state(intents=intents, **options)
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/discord/client.py:365: in _get_state
    return ConnectionState(dispatch=self.dispatch, handlers=self._handlers, hooks=self._hooks, http=self.http, **options)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord.state.ConnectionState object at 0x7c96ebd1ef90>
dispatch = <bound method Client.dispatch of <discord_bot.DiscordBot object at 0x7c96ebbd6e70>>
handlers = {'ready': <bound method Client._handle_ready of <discord_bot.DiscordBot object at 0x7c96ebbd6e70>>}
hooks = {'before_identify': <bound method Client._call_before_identify_hook of <discord_bot.DiscordBot object at 0x7c96ebbd6e70>>}
http = <discord.http.HTTPClient object at 0x7c96ebbd6c30>
options = {'intents': <MagicMock name='default()' id='136987643343072'>}
allowed_mentions = None, activity = None, status = None

    def __init__(
        self,
        *,
        dispatch: Callable[..., Any],
        handlers: Dict[str, Callable[..., Any]],
        hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]],
        http: HTTPClient,
        **options: Any,
    ) -> None:
        # Set later, after Client.login
        self.loop: asyncio.AbstractEventLoop = utils.MISSING
        self.http: HTTPClient = http
        self.max_messages: Optional[int] = options.get('max_messages', 1000)
        if self.max_messages is not None and self.max_messages <= 0:
            self.max_messages = 1000
    
        self.dispatch: Callable[..., Any] = dispatch
        self.handlers: Dict[str, Callable[..., Any]] = handlers
        self.hooks: Dict[str, Callable[..., Coroutine[Any, Any, Any]]] = hooks
        self.shard_count: Optional[int] = None
        self._ready_task: Optional[asyncio.Task] = None
        self.application_id: Optional[int] = utils._get_as_snowflake(options, 'application_id')
        self.application_flags: ApplicationFlags = utils.MISSING
        self.heartbeat_timeout: float = options.get('heartbeat_timeout', 60.0)
        self.guild_ready_timeout: float = options.get('guild_ready_timeout', 2.0)
        if self.guild_ready_timeout < 0:
            raise ValueError('guild_ready_timeout cannot be negative')
    
        allowed_mentions = options.get('allowed_mentions')
    
        if allowed_mentions is not None and not isinstance(allowed_mentions, AllowedMentions):
            raise TypeError('allowed_mentions parameter must be AllowedMentions')
    
        self.allowed_mentions: Optional[AllowedMentions] = allowed_mentions
        self._chunk_requests: Dict[Union[int, str], ChunkRequest] = {}
    
        activity = options.get('activity', None)
        if activity:
            if not isinstance(activity, BaseActivity):
                raise TypeError('activity parameter must derive from BaseActivity.')
    
            activity = activity.to_dict()
    
        status = options.get('status', None)
        if status:
            if status is Status.offline:
                status = 'invisible'
            else:
                status = str(status)
    
        intents = options.get('intents', None)
        if intents is not None:
            if not isinstance(intents, Intents):
>               raise TypeError(f'intents parameter must be Intent not {type(intents)!r}')
E               TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>

venv/lib/python3.14/site-packages/discord/state.py:233: TypeError
__________________________ test_ping_command_no_rcon ___________________________

bot = <discord_bot.DiscordBot object at 0x7c96ebfca450>
mock_interaction = <MagicMock spec='Interaction' id='136987641072336'>

    @pytest.mark.asyncio
    async def test_ping_command_no_rcon(bot, mock_interaction):
        """Test /factorio ping when RCON is not configured"""
        bot.rcon_client = None
    
        await bot._register_commands()
        group = bot.tree.add_command.call_args[0][0]
        ping_cmd = next(cmd for cmd in group.commands if cmd.name == "ping")
    
>       await ping_cmd.callback(mock_interaction)

tests/test_discord_bot_comprehensive.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interaction = <MagicMock spec='Interaction' id='136987641072336'>

    @factorio_group.command(name="ping", description="Ping the Factorio server via RCON")
    async def ping_command(interaction: discord.Interaction) -> None:
        """Check connectivity to the Factorio server and RCON."""
        is_limited, retry = QUERY_COOLDOWN.is_rate_limited(interaction.user.id)
        if is_limited:
            embed = EmbedBuilder.cooldown_embed(retry)
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return
    
        await interaction.response.defer()
    
        if self.rcon_client is None:
>           embed = EmbedBuilder.error_embed(
                "RCON is not configured. Cannot ping Factorio server."
            )
E           TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given

src/discord_bot.py:245: TypeError
_________________________ test_ping_command_rcon_error _________________________

interaction = <MagicMock spec='Interaction' id='136987641081408'>

    @factorio_group.command(name="ping", description="Ping the Factorio server via RCON")
    async def ping_command(interaction: discord.Interaction) -> None:
        """Check connectivity to the Factorio server and RCON."""
        is_limited, retry = QUERY_COOLDOWN.is_rate_limited(interaction.user.id)
        if is_limited:
            embed = EmbedBuilder.cooldown_embed(retry)
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return
    
        await interaction.response.defer()
    
        if self.rcon_client is None:
            embed = EmbedBuilder.error_embed(
                "RCON is not configured. Cannot ping Factorio server."
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
    
        try:
>           response = await self.rcon_client.execute("/time")
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/discord_bot.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AsyncMock name='mock.execute' id='136987641080064'>, args = ('/time',)
kwargs = {}, _call = call('/time'), effect = Exception('Connection failed')

    async def _execute_mock_call(self, /, *args, **kwargs):
        # This is nearly just like super(), except for special handling
        # of coroutines
    
        _call = _Call((args, kwargs), two=True)
        self.await_count += 1
        self.await_args = _call
        self.await_args_list.append(_call)
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               Exception: Connection failed

../../.pyenv/versions/3.14.0/lib/python3.14/unittest/mock.py:2326: Exception

During handling of the above exception, another exception occurred:

bot = <discord_bot.DiscordBot object at 0x7c96eba6d7f0>
mock_rcon = <MagicMock id='136987641079728'>
mock_interaction = <MagicMock spec='Interaction' id='136987641081408'>

    @pytest.mark.asyncio
    async def test_ping_command_rcon_error(bot, mock_rcon, mock_interaction):
        """Test /factorio ping when RCON raises exception"""
        bot.set_rcon_client(mock_rcon)
        mock_rcon.execute.side_effect = Exception("Connection failed")
    
        await bot._register_commands()
        group = bot.tree.add_command.call_args[0][0]
        ping_cmd = next(cmd for cmd in group.commands if cmd.name == "ping")
    
>       await ping_cmd.callback(mock_interaction)

tests/test_discord_bot_comprehensive.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interaction = <MagicMock spec='Interaction' id='136987641081408'>

    @factorio_group.command(name="ping", description="Ping the Factorio server via RCON")
    async def ping_command(interaction: discord.Interaction) -> None:
        """Check connectivity to the Factorio server and RCON."""
        is_limited, retry = QUERY_COOLDOWN.is_rate_limited(interaction.user.id)
        if is_limited:
            embed = EmbedBuilder.cooldown_embed(retry)
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return
    
        await interaction.response.defer()
    
        if self.rcon_client is None:
            embed = EmbedBuilder.error_embed(
                "RCON is not configured. Cannot ping Factorio server."
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
    
        try:
            response = await self.rcon_client.execute("/time")
            embed = EmbedBuilder.info_embed(
                title=" Ping Successful",
                message=f"Bot  RCON  Factorio server is reachable.\n\n**Response:** {response}"
            )
            await interaction.followup.send(embed=embed)
            logger.info("factorio_ping_success", user=interaction.user.name)
        except Exception as e:
>           embed = EmbedBuilder.error_embed(
                f"Could not reach Factorio server via RCON.\n**Error:** {str(e)}"
            )
E           TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given

src/discord_bot.py:260: TypeError
_________________________ test_players_command_success _________________________

bot = <discord_bot.DiscordBot object at 0x7c96ebfc9130>
mock_rcon = <MagicMock id='136987637996512'>
mock_interaction = <MagicMock spec='Interaction' id='136987637998192'>

    @pytest.mark.asyncio
    async def test_players_command_success(bot, mock_rcon, mock_interaction):
        """Test /factorio players with players online"""
        bot.set_rcon_client(mock_rcon)
        mock_rcon.is_connected = True
        mock_rcon.get_players.return_value = ["Alice", "Bob"]
    
        await bot._register_commands()
        group = bot.tree.add_command.call_args[0][0]
        players_cmd = next(cmd for cmd in group.commands if cmd.name == "players")
    
>       await players_cmd.callback(mock_interaction)

tests/test_discord_bot_comprehensive.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interaction = <MagicMock spec='Interaction' id='136987637998192'>

    @factorio_group.command(name="players", description="List players currently online")
    async def players_command(interaction: discord.Interaction) -> None:
        """List online players with rich embed."""
        is_limited, retry = QUERY_COOLDOWN.is_rate_limited(interaction.user.id)
        if is_limited:
>           embed = EmbedBuilder.cooldown_embed(retry)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given

src/discord_bot.py:307: TypeError
___________________ test_players_command_rcon_not_connected ____________________

bot = <discord_bot.DiscordBot object at 0x7c96eb7e1910>
mock_rcon = <MagicMock id='136987638005248'>
mock_interaction = <MagicMock spec='Interaction' id='136987637679504'>

    @pytest.mark.asyncio
    async def test_players_command_rcon_not_connected(bot, mock_rcon, mock_interaction):
        """Test /factorio players when RCON not connected"""
        bot.set_rcon_client(mock_rcon)
        mock_rcon.is_connected = False
    
        await bot._register_commands()
        group = bot.tree.add_command.call_args[0][0]
        players_cmd = next(cmd for cmd in group.commands if cmd.name == "players")
    
>       await players_cmd.callback(mock_interaction)

tests/test_discord_bot_comprehensive.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interaction = <MagicMock spec='Interaction' id='136987637679504'>

    @factorio_group.command(name="players", description="List players currently online")
    async def players_command(interaction: discord.Interaction) -> None:
        """List online players with rich embed."""
        is_limited, retry = QUERY_COOLDOWN.is_rate_limited(interaction.user.id)
        if is_limited:
>           embed = EmbedBuilder.cooldown_embed(retry)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given

src/discord_bot.py:307: TypeError
_____________________________ test_version_command _____________________________

bot = <discord_bot.DiscordBot object at 0x7c96eb7e2b10>
mock_rcon = <MagicMock id='136987637686224'>
mock_interaction = <MagicMock spec='Interaction' id='136987637687904'>

    @pytest.mark.asyncio
    async def test_version_command(bot, mock_rcon, mock_interaction):
        """Test /factorio version command"""
        bot.set_rcon_client(mock_rcon)
        mock_rcon.execute.return_value = "Factorio 1.1.104"
    
        await bot._register_commands()
        group = bot.tree.add_command.call_args[0][0]
        version_cmd = next(cmd for cmd in group.commands if cmd.name == "version")
    
>       await version_cmd.callback(mock_interaction)

tests/test_discord_bot_comprehensive.py:339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

interaction = <MagicMock spec='Interaction' id='136987637687904'>

    @factorio_group.command(name="version", description="Show Factorio server version")
    async def version_command(interaction: discord.Interaction) -> None:
        """Display the Factorio server version."""
        is_limited, retry = QUERY_COOLDOWN.is_rate_limited(interaction.user.id)
        if is_limited:
>           embed = EmbedBuilder.cooldown_embed(retry)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given

src/discord_bot.py:333: TypeError
_____________________ test_update_presence_rcon_connected ______________________

self = <AsyncMock name='change_presence' id='136987639236992'>

    def assert_awaited_once(self):
        """
        Assert that the mock was awaited exactly once.
        """
        if not self.await_count == 1:
            msg = (f"Expected {self._mock_name or 'mock'} to have been awaited once."
                   f" Awaited {self.await_count} times.")
>           raise AssertionError(msg)
E           AssertionError: Expected change_presence to have been awaited once. Awaited 0 times.

../../.pyenv/versions/3.14.0/lib/python3.14/unittest/mock.py:2369: AssertionError

During handling of the above exception, another exception occurred:

bot = <discord_bot.DiscordBot object at 0x7c96eb990170>
mock_rcon = <MagicMock id='136987639234976'>

    @pytest.mark.asyncio
    async def test_update_presence_rcon_connected(bot, mock_rcon):
        """Test update_presence when RCON is connected"""
        bot.connected = True
        bot.set_rcon_client(mock_rcon)
        mock_rcon.is_connected = True
    
        # Mock the user property
        with patch.object(type(bot), 'user', new_callable=PropertyMock) as mock_user:
            mock_user.return_value = MagicMock()
    
            with patch.object(bot, 'change_presence', new_callable=AsyncMock) as mock_change:
                await bot.update_presence()
    
>               mock_change.assert_awaited_once()
E               AssertionError: Expected change_presence to have been awaited once. Awaited 0 times.

tests/test_discord_bot_comprehensive.py:363: AssertionError
____________________ test_update_presence_rcon_disconnected ____________________

self = <AsyncMock name='change_presence' id='136987639242704'>

    def assert_awaited_once(self):
        """
        Assert that the mock was awaited exactly once.
        """
        if not self.await_count == 1:
            msg = (f"Expected {self._mock_name or 'mock'} to have been awaited once."
                   f" Awaited {self.await_count} times.")
>           raise AssertionError(msg)
E           AssertionError: Expected change_presence to have been awaited once. Awaited 0 times.

../../.pyenv/versions/3.14.0/lib/python3.14/unittest/mock.py:2369: AssertionError

During handling of the above exception, another exception occurred:

bot = <discord_bot.DiscordBot object at 0x7c96eb991490>
mock_rcon = <MagicMock id='136987639240688'>

    @pytest.mark.asyncio
    async def test_update_presence_rcon_disconnected(bot, mock_rcon):
        """Test update_presence when RCON is disconnected"""
        bot.connected = True
        bot.set_rcon_client(mock_rcon)
        mock_rcon.is_connected = False
    
        with patch.object(type(bot), 'user', new_callable=PropertyMock) as mock_user:
            mock_user.return_value = MagicMock()
    
            with patch.object(bot, 'change_presence', new_callable=AsyncMock) as mock_change:
                await bot.update_presence()
    
>               mock_change.assert_awaited_once()
E               AssertionError: Expected change_presence to have been awaited once. Awaited 0 times.

tests/test_discord_bot_comprehensive.py:381: AssertionError
_____________________ test_monitor_rcon_status_transition ______________________

bot = <discord_bot.DiscordBot object at 0x7c96eb992330>
mock_rcon = <MagicMock id='136987639246400'>
mock_text_channel = <MagicMock spec='TextChannel' id='136987639248080'>

    @pytest.mark.asyncio
    async def test_monitor_rcon_status_transition(bot, mock_rcon, mock_text_channel):
        """Test RCON monitoring detects connection status changes"""
        bot.connected = True
        bot.set_rcon_client(mock_rcon)
        bot.set_event_channel(123456)
    
        # Simulate: connected -> disconnected -> exit
        connection_states = [True, False]
    
        async def mock_sleep(duration):
            if connection_states:
                mock_rcon.is_connected = connection_states.pop(0)
            else:
                raise asyncio.CancelledError()
    
        with patch.object(bot, 'get_channel', return_value=mock_text_channel):
            with patch('discord_bot.asyncio.sleep', side_effect=mock_sleep):
                with patch.object(bot, 'update_presence', new_callable=AsyncMock):
                    try:
                        await bot._monitor_rcon_status()
                    except asyncio.CancelledError:
                        pass
    
        # Should have sent disconnection notification
>       assert mock_text_channel.send.await_count >= 1
E       AssertionError: assert 0 >= 1
E        +  where 0 = <AsyncMock name='mock.send' id='136987639248416'>.await_count
E        +    where <AsyncMock name='mock.send' id='136987639248416'> = <MagicMock spec='TextChannel' id='136987639248080'>.send

tests/test_discord_bot_comprehensive.py:411: AssertionError
________________________________ test_on_ready _________________________________

bot = <discord_bot.DiscordBot object at 0x7c96eb8729f0>

    @pytest.mark.asyncio
    async def test_on_ready(bot):
        """Test on_ready event handler"""
        # Mock user and guilds
        with patch.object(type(bot), 'user', new_callable=PropertyMock) as mock_user:
            mock_user.return_value = MagicMock(name="TestBot", id=12345)
    
            with patch.object(type(bot), 'guilds', new_callable=PropertyMock) as mock_guilds:
                mock_guilds.return_value = [MagicMock(name="Guild1", id=111)]
    
                bot.tree.sync = AsyncMock(return_value=[])
                bot.tree.copy_global_to = MagicMock()
    
                await bot.on_ready()
    
>               assert bot.connected is True
                       ^^^^^^^^^^^^^
E               AttributeError: 'DiscordBot' object has no attribute 'connected'. Did you mean: 'connect'?

tests/test_discord_bot_comprehensive.py:459: AttributeError
______________________________ test_on_disconnect ______________________________

bot = <discord_bot.DiscordBot object at 0x7c96eb206c30>

    @pytest.mark.asyncio
    async def test_on_disconnect(bot):
        """Test on_disconnect event handler"""
        bot.connected = True
    
        await bot.on_disconnect()
    
>       assert bot.connected is False
E       assert True is False
E        +  where True = <discord_bot.DiscordBot object at 0x7c96eb206c30>.connected

tests/test_discord_bot_comprehensive.py:470: AssertionError
________________________________ test_on_error _________________________________

bot = <discord_bot.DiscordBot object at 0x7c96eb206d50>

    @pytest.mark.asyncio
    async def test_on_error(bot):
        """Test on_error event handler"""
        # Should not raise exception
>       await bot.on_error("test_event", Exception("Test error"))

tests/test_discord_bot_comprehensive.py:477: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <discord_bot.DiscordBot object at 0x7c96eb206d50>, event = 'test_event'
args = (Exception('Test error'),), kwargs = {}

    async def on_error(self, event: str, *args, **kwargs) -> None:
        """Called when an error occurs."""
>       logger.error("discord_bot_error", event=event, exc_info=True)
E       TypeError: _make_filtering_bound_logger.<locals>.make_method.<locals>.meth() got multiple values for argument 'event'

src/discord_bot.py:1169: TypeError
_______________________________ test_connect_bot _______________________________

bot = <discord_bot.DiscordBot object at 0x7c96eb28c050>

    @pytest.mark.asyncio
    async def test_connect_bot(bot):
        """Test connect_bot starts monitoring"""
        with patch.object(bot, 'login', new_callable=AsyncMock):
            with patch('discord_bot.asyncio.create_task') as mock_create_task:
                mock_task = MagicMock()
                mock_create_task.return_value = mock_task
    
                with patch.object(bot, 'connect', new_callable=AsyncMock):
                    with patch('discord_bot.asyncio.wait_for', new_callable=AsyncMock):
                        with patch.object(bot, '_send_connection_notification', new_callable=AsyncMock):
                            with patch.object(bot, 'update_presence', new_callable=AsyncMock):
>                               bot.ready.set()  # Pre-set ready to avoid timeout
                                ^^^^^^^^^
E                               AttributeError: 'DiscordBot' object has no attribute 'ready'

tests/test_discord_bot_comprehensive.py:492: AttributeError
_____________________________ test_disconnect_bot ______________________________

bot = <discord_bot.DiscordBot object at 0x7c96eb992f90>

    @pytest.mark.asyncio
    async def test_disconnect_bot(bot):
        """Test disconnect_bot stops monitoring"""
        bot.connected = True
        bot.rcon_monitor_task = MagicMock()
        bot.rcon_monitor_task.cancel = MagicMock()
    
        with patch.object(bot, '_send_disconnection_notification', new_callable=AsyncMock):
            with patch.object(bot, 'is_closed', return_value=False):
                with patch.object(bot, 'close', new_callable=AsyncMock):
                    await bot.disconnect_bot()
    
>       assert bot.connected is False
E       assert True is False
E        +  where True = <discord_bot.DiscordBot object at 0x7c96eb992f90>.connected

tests/test_discord_bot_comprehensive.py:512: AssertionError
_____________________ test_send_disconnection_notification _____________________

self = <AsyncMock name='mock.send' id='136987632594160'>

    def assert_awaited_once(self):
        """
        Assert that the mock was awaited exactly once.
        """
        if not self.await_count == 1:
            msg = (f"Expected {self._mock_name or 'mock'} to have been awaited once."
                   f" Awaited {self.await_count} times.")
>           raise AssertionError(msg)
E           AssertionError: Expected send to have been awaited once. Awaited 0 times.

../../.pyenv/versions/3.14.0/lib/python3.14/unittest/mock.py:2369: AssertionError

During handling of the above exception, another exception occurred:

bot = <discord_bot.DiscordBot object at 0x7c96eb28f1d0>
mock_text_channel = <MagicMock spec='TextChannel' id='136987632595840'>

    @pytest.mark.asyncio
    async def test_send_disconnection_notification(bot, mock_text_channel):
        """Test _send_disconnection_notification sends message"""
        bot.connected = True
        bot.set_event_channel(123456)
    
        with patch.object(type(bot), 'user', new_callable=PropertyMock) as mock_user:
            mock_user.return_value = MagicMock(name="TestBot")
    
            with patch.object(bot, 'get_channel', return_value=mock_text_channel):
                await bot._send_disconnection_notification()
    
>       mock_text_channel.send.assert_awaited_once()
E       AssertionError: Expected send to have been awaited once. Awaited 0 times.

tests/test_discord_bot_comprehensive.py:549: AssertionError
___________________________ test_send_event_success ____________________________

bot = <discord_bot.DiscordBot object at 0x7c96eb28f0b0>
mock_text_channel = <MagicMock spec='TextChannel' id='136987632590800'>

    @pytest.mark.asyncio
    async def test_send_event_success(bot, mock_text_channel):
        """Test send_event successfully sends event"""
        bot.connected = True
        bot.set_event_channel(123456)
    
        event = SimpleNamespace(
            event_type=SimpleNamespace(value="player_join"),
            data={"player": "Alice"}
        )
    
        with patch.object(bot, 'get_channel', return_value=mock_text_channel):
            with patch('discord_bot.FactorioEventFormatter.format_for_discord', return_value="Player joined"):
                result = await bot.send_event(event)
    
>       assert result is True
E       assert False is True

tests/test_discord_bot_comprehensive.py:567: AssertionError
=============================== warnings summary ===============================
tests/test_discord_bot_comprehensive.py::test_notify_rcon_reconnected
  /home/slau/code/factorio-isr/tests/test_discord_bot_comprehensive.py:431: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    bot.rcon_last_connected = datetime.utcnow()

tests/test_discord_bot_comprehensive.py::test_notify_rcon_reconnected
  /home/slau/code/factorio-isr/tests/../src/discord_bot.py:183: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    downtime = datetime.utcnow() - self.rcon_last_connected

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.14.0-final-0 ________________

Name                         Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------
src/__init__.py                  0      0      0      0   100%
src/__version__.py               1      1      0      0     0%   1
src/config.py                  133    133     48      0     0%   2-248
src/discord_bot.py             812    590    174     19    25%   47->53, 84-105, 113-145, 150, 154->exit, 169-170, 175, 179->exit, 182->188, 186, 201-202, 214-215, 238-240, 248-249, 263-264, 271-273, 297-300, 308-326, 334-355, 360-378, 383-401, 406-424, 430-489, 506-537, 543-572, 578-607, 613-642, 648-677, 683-712, 718-747, 756-804, 810-838, 851-905, 915-950, 956-987, 993-1023, 1033-1059, 1064-1104, 1122-1123, 1159-1160, 1177-1215, 1220-1250, 1259-1260, 1265-1266, 1283-1286, 1294-1321, 1341-1369
src/discord_client.py           96     96     28      0     0%   6-229
src/discord_interface.py       286    217     62      0    20%   24-26, 39-40, 67-77, 87-99, 104-117, 128-143, 148, 157, 166, 184-186, 190-192, 196-203, 207-217, 221-229, 264-265, 287-288, 291-293, 296-298, 301, 304, 307, 311, 322-335, 338-343, 350-354, 357, 360-394, 397-431, 434, 438, 462-571
src/event_parser.py            142    103     52      0    20%   70-79, 83-109, 121-133, 144-209, 215-222, 233-251, 260-263, 274-315
src/health.py                   32     32      4      0     0%   6-91
src/log_tailer.py               98     98     30      0     0%   6-219
src/main.py                    195    195     38      0     0%   11-390
src/pattern_loader.py          151    137     46      0     7%   41-64, 84-87, 99-149, 161-332, 344-357, 369-379, 388-397
src/rcon_client.py             202    202     48      0     0%   8-451
src/utils/__init__.py            3      0      0      0   100%
src/utils/multi_server.py       74     48     28      0    25%   28-39, 48, 55-57, 70-77, 96-105, 118-125, 137-141, 145, 149, 161-165, 174, 183, 192, 196, 200, 204
src/utils/rate_limiting.py      42     13      6      1    67%   46, 71-73, 77, 81-82, 94-100, 104-105
------------------------------------------------------------------------
TOTAL                         2267   1865    564     20    15%
Coverage HTML written to dir htmlcov
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_discord_bot_comprehensive.py::test_init_default - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
FAILED tests/test_discord_bot_comprehensive.py::test_init_custom_bot_name - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
FAILED tests/test_discord_bot_comprehensive.py::test_is_connected_property - assert False is True
 +  where False = <discord_bot.DiscordBot object at 0x7c96ebec3e10>.is_connected
FAILED tests/test_discord_bot_comprehensive.py::test_factory_create_bot - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
FAILED tests/test_discord_bot_comprehensive.py::test_ping_command_no_rcon - TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given
FAILED tests/test_discord_bot_comprehensive.py::test_ping_command_rcon_error - TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given
FAILED tests/test_discord_bot_comprehensive.py::test_players_command_success - TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given
FAILED tests/test_discord_bot_comprehensive.py::test_players_command_rcon_not_connected - TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given
FAILED tests/test_discord_bot_comprehensive.py::test_version_command - TypeError: patch_embedbuilder.<locals>.mock_embed() takes 0 positional arguments but 1 was given
FAILED tests/test_discord_bot_comprehensive.py::test_update_presence_rcon_connected - AssertionError: Expected change_presence to have been awaited once. Awaited 0 times.
FAILED tests/test_discord_bot_comprehensive.py::test_update_presence_rcon_disconnected - AssertionError: Expected change_presence to have been awaited once. Awaited 0 times.
FAILED tests/test_discord_bot_comprehensive.py::test_monitor_rcon_status_transition - AssertionError: assert 0 >= 1
 +  where 0 = <AsyncMock name='mock.send' id='136987639248416'>.await_count
 +    where <AsyncMock name='mock.send' id='136987639248416'> = <MagicMock spec='TextChannel' id='136987639248080'>.send
FAILED tests/test_discord_bot_comprehensive.py::test_on_ready - AttributeError: 'DiscordBot' object has no attribute 'connected'. Did you mean: 'connect'?
FAILED tests/test_discord_bot_comprehensive.py::test_on_disconnect - assert True is False
 +  where True = <discord_bot.DiscordBot object at 0x7c96eb206c30>.connected
FAILED tests/test_discord_bot_comprehensive.py::test_on_error - TypeError: _make_filtering_bound_logger.<locals>.make_method.<locals>.meth() got multiple values for argument 'event'
FAILED tests/test_discord_bot_comprehensive.py::test_connect_bot - AttributeError: 'DiscordBot' object has no attribute 'ready'
FAILED tests/test_discord_bot_comprehensive.py::test_disconnect_bot - assert True is False
 +  where True = <discord_bot.DiscordBot object at 0x7c96eb992f90>.connected
FAILED tests/test_discord_bot_comprehensive.py::test_send_disconnection_notification - AssertionError: Expected send to have been awaited once. Awaited 0 times.
FAILED tests/test_discord_bot_comprehensive.py::test_send_event_success - assert False is True
ERROR tests/test_discord_bot_booster.py::test_seed_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_evolution_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_admins_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_health_command_all_online - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_health_command_rcon_offline - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_kick_command_with_reason - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_kick_command_without_reason - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_ban_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_unban_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_mute_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_unmute_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_promote_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_demote_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_save_command_with_name - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_save_command_auto_name - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_broadcast_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_whitelist_list - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_whitelist_add - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_whitelist_remove - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_whitelist_enable - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_whitelist_disable - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_whitelist_invalid_action - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_time_command_display - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_time_command_set - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_speed_command_valid - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_speed_command_too_low - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_speed_command_too_high - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_research_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_rcon_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
ERROR tests/test_discord_bot_booster.py::test_help_command - TypeError: intents parameter must be Intent not <class 'unittest.mock.MagicMock'>
============= 19 failed, 16 passed, 2 warnings, 30 errors in 4.79s =============
